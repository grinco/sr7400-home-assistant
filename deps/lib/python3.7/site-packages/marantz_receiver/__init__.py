"""
Marantz has an RS232 interface to control the receiver.

Not all receivers have all functions.
Functions can be found on in the xls file within this repository
"""

import codecs
import socket
from time import sleep
from marantz_receiver.marantz_commands import CMDS
import serial  # pylint: disable=import-error
import threading
import telnetlib
import logging
import time

DEFAULT_TIMEOUT = 0.5
DEFAULT_WRITE_TIMEOUT = 0.5

_LOGGER = logging.getLogger(__name__)

class MarantzReceiver(object):
    """Marantz receiver."""

    def __init__(self, serial_port, timeout=DEFAULT_TIMEOUT,
                 write_timeout=DEFAULT_WRITE_TIMEOUT):
        """Create RS232 connection."""
        self.ser = serial.Serial(serial_port, baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=timeout,
                                 write_timeout=write_timeout)
        self.lock = threading.Lock()

    def exec_command(self, domain, function, operator, value=None):
        """
        Write a command to the receiver and read the value it returns.
        The receiver will always return a value, also when setting a value.
        """
        raw_command = CMDS[domain][function]['cmd']
        if operator in CMDS[domain][function]['supported_operators']:
            if value is None:
                raise ValueError('No value provided')
            else:
                cmd = ''.join([operator, raw_command, str(value)])

        else:
            raise ValueError('Invalid operator provided %s' % operator)
        with self.lock:
            if not self.ser.is_open:
                self.ser.open()

            self.ser.reset_input_buffer()
            self.ser.reset_output_buffer()
#            self.lock.acquire()

            # Marantz uses the prefix @1 and the suffix \r, so add those to the above cmd.
            final_command = ''.join(['@1', cmd, '\r']).encode('utf-8')
            _LOGGER.debug ('Send Command %s',final_command)

            self.ser.write(final_command)

            msg = self.ser.read_until(bytes('\r'.encode()))
#            self.lock.release()

        _LOGGER.debug ('Response msg: %s', msg.decode())

        response = msg.decode().strip('@1')

        _LOGGER.debug("Decoded response: %s", response)
        if response == ('ACK'):
            _LOGGER.debug ("Command %s executed successfully", cmd )
            return True
        elif response == ('NAK'):
            _LOGGER.debug ("Command %s executed unsuccessfully", cmd )
            return False
        else:
            _LOGGER.debug ("Command %s returned: %s", cmd, response[1:])
            return response[1:].strip()

    def main_mute(self, operator, value=None):
        """Execute Main.Mute."""
        return self.exec_command('main', 'mute', operator, value)

    def main_power(self, operator, value=None):
        """Execute Main.Power."""
        return self.exec_command('main', 'power', operator, value)

    def main_volume(self, operator, value=None):
        """
        Execute Main.Volume.
        Returns int
        """
        vol_result = self.exec_command('main', 'volume', operator, value)
        if len(vol_result) >= 3:
           volume = vol_result.strip('A')
           _LOGGER.debug("Volume level: %s", volume)
           return int(volume)
        else:
           _LOGGER.debug("Volume level is not set: %s (%s)", vol_result, len(vol_result))
           return vol_result

    def main_source(self, operator, value=None):
        """Execute Main.Source."""
        result = self.exec_command('main', 'source', operator, value)
        """
        The receiver often returns the source value twice. If so take the
        second value as the source, otherwise return original
        """
        _LOGGER.debug("Source Result: %s", result)
        return result

    def main_sound_mode(self, operator, value=None):
        """Execute Main.SoundMode."""
        result_sound_mode = self.exec_command('main', 'sound_mode', operator, value)

        if result_sound_mode != None:
          _LOGGER.debug("Sound_Mode Result: %s", result_sound_mode)
          return result_sound_mode

